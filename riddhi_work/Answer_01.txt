
Multi Threading is to work parallely on a task at a same time. Through Python it is possible but with some limitations. For example, there are five (5) threads, and you are working on 1st thread. 
That thread has a GIL (Global Inter Lock). So, if you want to work on 2nd thread you first need to remove GIL from 1st thread, then and only then you can work on 2nd thread. And so on. Python interpretor has the property to change threads automatically after few seconds or fraction of seconds. In a nutshell we can use threading in Python, but we can not work on multi threads at a same time.


  

Memory management in Python involves a private heap containing all Python objects and data structures. The management of this private heap is ensured internally by the Python memory manager. The Python memory manager has different components which deal with various dynamic storage management aspects, like sharing, segmentation, preallocation or caching. 
At the lowest level, a raw memory allocator ensures that there is enough room in the private heap for storing all Python-related data by interacting with the memory manager of the operating system. On top of the raw memory allocator, several object-specific allocators operate on the same heap and implement distinct memory management policies adapted to the peculiarities of every object type. For example, integer objects are managed differently within the heap than strings, tuples or dictionaries because integers imply different storage requirements and speed/space tradeoffs. The Python memory manager thus delegates some of the work to the object-specific allocators, but ensures that the latter operate within the bounds of the private heap.
Now to see actully how the memory management works in python lets take one example. Python has its own interpretor, that maintain the table where it keep track of all objects and its number of references. 
For example, lets take one variable "a" and assign a value "5", so our object count is 1 and number of refereence is 1. Let's take another variable "b" and assign it to "a", it will increase the reference number as 2. Next if we delete variable "a", reference # will be 1 again. Now assign a new value "7" to "b", it will increase the object number to 2 and the reference # for the value 5 is now 0, which is known as Dead object. Here the Garbage collector come in picture, as soon as Python garbage collector sees any dead object it release that memory. The algorithm used for Garbage couting.
